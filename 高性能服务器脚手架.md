## 项目描述

这个项目是在Linux系统中采用C++语言编写的一个高性能服务器框架，框架实现好了数据包的收发操作，具体的业务处理逻辑看用户怎么实现，框架收到包之后会识别包头的信息，根据里面的标号就知道要执行那个业务函数了。

 

## 框架启动步骤都做了哪些工作

1.设置**进程退出标志**，当前**进程与父进程id**，**命令行参数和环境变量所需内存空间**。

> [!NOTE]
>
> ###### 获取进程ID的作用？
>
> - ngx_pid = getpid() 获取当前进程ID：用于进程管理、日志记录、信号处理等
> - ngx_parent = getppid() 获取父进程ID：用于实现master-worker进程模型，worker进程需要知道master进程的ID
>
> ###### 统计内存空间的作用？
>
> - 为了实现修改进程标题功能(设置ps命令看到的进程名)
>
> - 需要将原始的环境变量复制到新的内存空间，以便释放argv和environ原来的空间来存储新的进程标题
>
> - environ是系统环境变量，包含：
>
> - PATH：可执行文件搜索路径
> - HOME：用户主目录
> - SHELL：当前shell类型
> - USER：当前用户名
>
> 等系统运行相关的配置信息
>
> 这个设计是为了能够动态修改进程名称，使系统管理更直观，同时又不影响程序对环境变量的正常访问。

2.**读取配置文件**（单例类），包括

- **日志**：输出目录和文件名，日志等级；
- **进程**：worker进程数，线程池中的线程数；
- **网络**：监听端口信息（个数和对应的端口号），epoll最大连接数，连接延迟回收时间，心跳检测时间等；
- **网络安全**：flood攻击相关的内容。

3.一系列**核心组件**的初始化：

- **内存管理**单例CMemery;
- **CRC32校验**算法单例；
- 初始化**日志**系统**ngx_log_init**；
- 初始化**信号**处理；
- 初始化**socket**；
- 进程**标题设置**；

4.创建**守护进程**；

5.进入主循环；



## 包头包体是怎么设计的，什么是粘包

1.包头结构体

```C++
//结构定义------------------------------------
#pragma pack (1) //对齐方式,1字节对齐【结构之间成员不做任何字节对齐：紧密的排列在一起】

//一些和网络通讯相关的结构放在这里
//包头结构
typedef struct _COMM_PKG_HEADER
{
	unsigned short pkgLen;    //报文总长度【包头+包体】--2字节，2字节可以表示的最大数字为6万多，我们定义_PKG_MAX_LENGTH 30000，所以用pkgLen足够保存下
	                            //包头中记录着整个包【包头—+包体】的长度

	unsigned short msgCode;   //消息类型代码--2字节，用于区别每个不同的命令【不同的消息】
	int            crc32;     //CRC32效验--4字节，为了防止收发数据中出现收到内容和发送内容不一致的情况，引入这个字段做一个基本的校验用	
}COMM_PKG_HEADER,*LPCOMM_PKG_HEADER;


#pragma pack() //取消指定对齐，恢复缺省对齐

```



## 守护进程的创建流程

1.fork一个子进程，父进程调用freeresource()释放资源，设置exitcode=0后直接退出，此时子进程成为孤儿进程，由init进程接管。

2.子进程调用setsid成为新会话的领导，脱离终端，进程不受终端信号影响。

3.设置umask(0)。

> [!NOTE]
>
> ###### 作用？
>
> 不要让从父进程继承来的文件权限掩码影响进程**创建**文件的权限。（子进程会创建的文件：日志文件，socket文件）

4.重定向标准输入输出和错误到dev/null。

> [!NOTE]
>
> ###### 作用？
>
> 防止守护进程读取终端。

5.如果需要还要更改工作目录。

> [!NOTE]
>
> ###### 作用？
>
> 防止目录被卸载（如U盘）。

## 线程池是怎么设计的

1.线程池在worker进程的初始化阶段创建。

> [!NOTE]
>
> ###### 线程池有哪些属性？
>
> - 互斥量（m_pthreadMutex），条件变量（m_pthreadCond）
> - 退出标志（m_shutdown）
> - 要创建的线程数（m_iThreadNum），正在运行的线程数（m_iRunningThreadNum）
> - 线程容器（**std**::vector<ThreadItem *> m_threadVector）
> - 接收消息队列（**std**::list<char *>     m_MsgRecvQueue），以及消息队列大小

> [!NOTE]
>
> ###### 一个线程是如何描述的？
>
> - 在线程池内定义了一个**ThreadItem**结构体用来描述一个线程，包括三个属性：线程句柄（pthread_t  _Handle，即**pthread_create**的第一个参数，也即一个线程的TID），线程池指针（CThreadPool *_pThis，在线程的构造函数中初始化），以及一个运行标记（bool   ifrunning，构造函数默认赋值为false）。
> - ifrunning的作用是标记线程正在运行，只有所有线程都就绪了才能调用StopAll函数，防止线程状态混乱。

2.worker进程调用g_threadpool.**Create**(tmpthreadnums)创建线程

> [!NOTE]
>
> ###### Create函数的逻辑？
>
> 根据要创建的线程数，for循环调用**pthread_create**(&pNew->_Handle, **NULL**, **ThreadFunc**, pNew)创建线程，创建后每个线程都会执行线程函数ThreadFunc，并阻塞等待任务。

> [!NOTE]
>
> ###### 单个线程的线程函数逻辑？
>
> - 线程函数的传入参数即为**ThreadItem**结构体指针，将这个void指针转化为**ThreadItem** *，并取得其中的线程池对象指针。
> - 获取CMemory单例。
> - 进入主循环。线程直接获得互斥锁，然后开始等待条件变量（**等待的过程中并不持有锁**）。被条件变量唤醒后自动重新获得锁，取出任务更新任务数和正在运行的线程数。释放锁，开始处理任务。处理完成后释放内存资源（**FreeMemory**）。
> - 若shutdown为true，退出主循环。返回(void*)0代表一种成功的状态，可用（void*）-1表示失败。也可以返回计算结果或复杂数据结构。返回(void*)0比较简单。

3.优雅关闭线程池（StopAll）

- 首先检查m_shutdown标志，防止重复关闭
- **pthread_cond_broadcast**(&m_pthreadCond)唤醒所有线程
- pthread_join遍历回收线程

> [!NOTE]
>
> ###### pthread_join所做的工作？
>
> - 回收子线程占用的**线程描述符**和**栈空间**
> - 获得子线程退出状态（第二个参数设为NULL则不关心）

- 销毁同步对象，互斥锁，信号量
- 清理资源：释放每个ThreadItem对象并清空线程容器vector。

## 设计一个线程池需要考虑哪些东西



## 连接池怎么实现的

1.连接池的初始化，函数（**initconnection**）

- 首先创建一个**lpngx_connection_t** p_Conn

> [!NOTE]
>
> ###### lpngx_connection_t结构体指针有那些内容？
>
> 1.管理连接状态:
>
> - 保存socket句柄和客户端地址
>
> - 记录连接的序号和状态
>
> - 关联监听对象
>
> 2.处理网络数据:
>
> - 提供收发数据的缓冲区
>
> - 记录数据处理状态
>
> - 关联读写事件处理函数
>
> 3.实现安全机制:
>
> - 心跳包检测
>
> - Flood攻击防护
>
> - 发送队列控制
>
> 4.支持连接池:
>
> - 通过next指针串联空闲连接
>
> - 记录回收时间
>
> - 提供互斥访问保护
>
> **每个连接对象能够完整地管理一个客户端连接的所有相关资源和状态**。

- 获取CMemory单例用于获取内存

- for循环创建连接对象

  - 调用**AllocMemory**分配内存
  - placement new在已有内存上构造对象
  - 调用p_Conn->**GetOneToUse**()

  > [!NOTE]
  >
  > ###### GetOneToUse函数做了什么？
  >
  > **初始化**各种数据，状态，计数器和标记，**保证每次获取的连接对象都处于一个干净可用的状态**，避免之前连接的残留数据对新连接造成影响。

  - 把连接对象放在两个list里，一个是放所有连接的，一个是放空闲连接的。最后记录一下两个list的长度。

2.将客户端连接和连接池中的一个对象进行绑定（**ngx_get_connection**函数）

- 接收一个socket
- 从空闲连接队列中拿一个连接，绑定传入的socket后返回
- 如果没有空闲连接，则创建一个新连接放在连接list中（不放在空闲list中，因为该连接必然是要用的）。

3.关闭连接函数（**ngx_close_connection**）

- 接收一个连接对象
- 调用**ngx_free_connection**(pConn)

> [!NOTE]
>
> ###### ngx_free_connection的逻辑？
>
> - 加锁访问连接池
> - 调用**PutOneToFree**函数：清理曾经分配过的内存，包括接收数据的内存和发送缓冲区的内存
> - 把清理好的连接放在空闲list里

- 关闭文件描述符

4.将连接放入回收队列（**inRecyConnectQueue**）

- 用于实现延迟回收
- 放入队列的连接等待连接回收线程来回收

5.回收整个连接池（**clearconnection**）

- 获取CMemery单例，循环释放所有连接的内存

> [!NOTE]
>
> ###### 为什么要手动调用析构函数？
>
> 因为创建连接对象时使用了placement new。



## 为什么要用连接池



## 收发包的过程是怎样的

### 收包过程：

1.新连接建立（**ngx_event_accept**）

> [!NOTE]
>
> ###### 新连接建立过程？
>
> - ngx_event_accept函数接收监听套接字oldc，并生成新的连接套接字newc
>
> - 调用accept/accept4，检查是否出错
> - 如果用户连接数过多，就关闭连接
> - 连接限制检查：如果连接池连接数很多（超过设定的最大连接数的5倍），并且空闲连接数很少（小于设定的最大连接数），说明短时间内产生了大量的连接，这些连接还在垃圾池里没有回收。于是就要拒绝新的连接
> - 给新连接分配连接对象，并初始化连接对象的属性，包括客户端地址信息，设置**数据处理函数**等
> - 调用**ngx_epoll_oper_event**添加监听套接字
> - 如果启用了踢人机制就把该连接加入到定时器队列

> [!NOTE]
>
> ###### accept4函数？
>
> 是accept的扩展版本，相比传统的 `accept()` 增加了对连接套接字行为的原子化控制，比如第四个参数设置为SOCK_NONBLOCK，新套接字设为**非阻塞模式**（无需再调 `fcntl(O_NONBLOCK)`）。

2.读数据流程

- 读事件处理函数（**ngx_read_request_handler**）

> [!NOTE]
>
> ###### 读事件处理函数的逻辑？
>
> - 先调用recvproc函数
> - 利用有限状态机来进行包的读取：1）**_PKG_HD_INIT**状态：正在读包头，如果读到完整包头就调用包头解析函数ngx_wait_request_handler_proc_p1；2）**_PKG_HD_RECVING**状态：包头不完整，继续接收包头的状态，一直到包头读完整；3）**_PKG_BD_INIT**状态：读完包头进入读包体状态；4）**_PKG_BD_RECVING**状态：包体未读完的状态，会一直读取到包体完整
> - 最后检测是否为flood攻击，如果是，就关闭连接（**zdClosesocketProc**函数）
>
> **当前实现不够完整！！！**

- 接收数据的具体处理（**recvproc**）

> [!NOTE]
>
> ###### recvproc的处理逻辑？
>
> - 调用recv接收数据，最终返回收到的字节数
> - 如果recv返回值为0，则表示对端关闭，调用zdClosesocketProc
> - 或者出现一些错误，都调用zdClosesocketProc关闭连接
> - 更新心跳时间（原代码未实现）

- 包头处理（**ngx_wait_request_handler_proc_p1**）

> [!NOTE]
>
> ###### 包头处理函数逻辑？
>
> - 首先判断包头长度是否合法
> - 分配内存用来构建消息体+包头+包体
> - 填写消息头和包头数据（pTmpBuffer）
> - 包头处理完毕，如果没有包体，则直接调用ngx_wait_request_handler_proc_plast处理完整包。如果还有包体，设置状态**_PKG_BD_INIT**，调整缓冲区指针pConn->precvbuf和待接收的数据量Conn->irecvlen

- 完整包处理（**ngx_wait_request_handler_proc_plast**）

> [!NOTE]
>
> ###### ngx_wait_request_handler_proc_plast函数逻辑？
>
> - 检查是否是flood攻击，如果是则对其，并释放相应内存。
> - 如果不是，则正常调用g_threadpool.**inMsgRecvQueueAndSignal**，入消息队列并触发线程处理消息（放进消息队列的包括**消息头包头和包体**）
> - 状态重置，准备接收下一个数据包

3.数据处理

- 数据被读取完毕放进任务队列，一个等待条件变量的线程被唤醒，执行**threadRecvProcFunc**（**CRC32校验**在此进行）
- 经过一系列检查和处理，根据包里的消息码执行相应的业务处理函数
- 业务处理完毕后调用**msgSend**，将响应数据包放在发送队列中，调用sem_post通知发送线程来发送数据

4.专门处理发送消息的线程

- 线程函数：void* **CSocekt**::**ServerSendQueueThread**(void* threadData)
- 如果内核缓冲区够用，发送线程发送完即可。如果内核缓冲区满了，则注册写事件，等待epoll通知，若通知可写，则由worker主线程调用ngx_write_request_handler发送数据

5.写数据流程

- 写事件处理函数（**ngx_write_request_handler**）
- 发送数据处理（**sendproc**）
- 消息发送入队（**msgSend**）

### 发送响应过程：

> [!NOTE]
>
> ###### 发送数据线程逻辑？
>
> 从一个**std**::**list**<char *>  m_MsgSendQueue里拿数据
>
> while循环发送数据，每一条数据加一个判断：消息头的连接序号和一个连接对象的连接序号是否匹配，不匹配则直接丢弃数据包。
>
> 三种情况：1）完整发送；2）部分发送（EAGAIN），或写入长度为-1，则缓冲区满（iThrowsendCount标记缓冲区满事件），更新一下发送指针和发送长度，注册epoll写事件，让主线程完成后续写工作；3）其他情况，释放内存，相当于丢弃该包。



## 目前实现了什么业务逻辑

1.注册功能（**_HandleRegister**函数）

- 接收四个参数：连接指针（即一个连接对象），消息头指针，包体指针，包体长度
- 检查包体的合法性，例如如果包体长度不等于注册结构体的长度，则丢弃
- 构造响应：消息头直接拷贝，包头和包体按需构造
- 计算CRC32

2.登录功能（**_HandleLogIn**函数）

- 与注册函数逻辑基本一致

3.心跳包处理函数

- 发来的心跳包应该没有包体
- 收到心跳包后就更新lastPingTime，处理超时连接的线程会检查这个变量
- 服务器也会发一个只有包头的数据包给客户端作为回应

## 为什么在应用层实现CRC32校验，怎么实现的

> [!NOTE]
>
> ###### 数据链路层已经有CRC32校验，为什么还要在应用层实现？
>
> 因为数据链路层在网络传输的最底层，只能检测传输过程中的错误。无法检测链路层以上的错误，比如数据在内存中被修改，或者数据在应用层被错误处理。
>
> 同时使用查表法计算CRC32，性能开销不大



1.CRC（Cyclic Redundancy Check,循环冗余校验）计算步骤：

- 展开生成多项式得到CRC除数
- 原数据末尾加0（多项式最高位是几次就加几个）
- 从左到右按位异或得到的结果即为CRC校验码

## 延迟回收怎么实现的，为什么要使用延迟回收

1.主动关闭一个连接时，会先调用**CSocekt**::zdClosesocketProc函数，如果开启了定时，先把连接从定时队列里删除（**DeleteFromTimerQueue**）

2.然后关闭相应的文件描述符

3.调用inRecyConnectQueue,把连接对象放在回收队列里

4.后台回收线程会在一定时间后进行回收

## master进程的作用

1.设置信号屏蔽集，设置新的信号屏蔽字

> [!NOTE]
>
> ###### 为什么要屏蔽信号集？
>
> - \- **fork**() 子进程时需要保护，防止信号中断导致进程创建混乱
> - \- 某些关键操作(如进程初始化)期间不希望被信号打断
>
> ###### 信号处理相关函数？
>
> - sigemptyset(&set)初始化信号集为空，表示不包含任何信号
> - `sigaddset(&set, SIGXXX)`
>   向信号集添加指定信号（如`SIGCHLD`、`SIGTERM`等），后续用于屏蔽这些信号
> - sigprocmask(SIG_BLOCK, &set, NULL)作用**：
>   将`set`中的信号加入当前进程的**阻塞信号集**，这些信号在解除屏蔽前**不会中断进程执行**
> - `sigsuspend(&set)`**作用**：
>   临时将进程信号屏蔽字替换为`&set`（此处为空集），并挂起进程**直到任一信号到达**
>
> ###### nginx信号处理流程
>
> - **初始化阶段**：
>   屏蔽关键信号 → 创建Worker子进程 → 解除屏蔽并进入信号等待循环
>
> - **信号处理**：
>
>   主进程通过`sigsuspend`挂起，信号触发后调用对应处理函数（如`ngx_signal_handler`）

2.设置主进程的标题

3.创建子进程，即worker进程

4.工作进程初始化（已经不是master进程的工作了）

- 线程池初始化
- 三个功能线程的初始化
- epoll初始化
- 连接池初始化
- 开始监听端口

5.通过sigsuspend等待信号

- 目前除了sigchild信号，别的都没有进行处理

## worker进程是如何创建的

父进程**fork**出来的，创建几个取决于配置文件中的设置。

**初始化过程**（**ngx_worker_process_init**(int inum)）：

1.清空信号集

2.初始化线程池

- 读取配置文件获得线程池中的线程数

3.初始化socket（**Initialize_subproc**）

- 初始化四个互斥锁，包括：1）发消息用的；2）建立连接相关；3）连接回收队列相关；4）时间处理队列相关
- 一个发消息相关的信号量
- 创建三个线程，分别是发送数据、回收连接和踢人（不发心跳包），都放在线程池线程容器vector里

4.其他初始化（**ngx_epoll_init**（））

- 创建epoll对象
- 初始化连接池（**initconnection**（）），这里应该把连接池的初始化单独摘出来，不应该和epoll的初始化放在一起。
- 将监听socket加入epoll管理

> [!NOTE]
>
> ###### worker进程对监听socket的初始化？
>
> - 为每个监听socket分配一个连接对象
> - 设置该连接对象的读处理函数为**ngx_event_accept**
> - 调用**ngx_epoll_oper_event**函数（该函数负责往红黑树上增加，修改，删除socket）

> [!NOTE]
>
> ###### 为什么子进程可以直接使用g_socket调用ngx_epoll_init函数进行初始化？
>
> fork后子进程继承了父进程的g_socket副本，各个进程都有自己独立的g_socket实例。

5.进入死循环，执行**ngx_process_events_and_timers**()，阻塞在epoll_wait。

## worker进程

1.**特点**：

- 有**独立**的线程池，消息队列，连接池和定时器队列。
- 进程之间相互独立不互相影响。每个进程都可以独立处理连接和请求。提高了**并发处理**能力。进程崩溃不会影响其他进程。

## 处理连接回收的线程逻辑

1.每隔200ms进行一次检测

2.遍历回收队列，检查是否到达回收时间（进入回收队列的时刻加上设定的延迟回收事件和当前时刻做比较）

3.检查发送队列是否为空，不为空输出错误，未进行更多处理

4.执行释放操作，调用**ngx_free_connection**，将空闲连接放进空闲连接队列里

5.如果系统关闭（g_stopEvent == 1），则强制回收所有连接

## 关闭程序的逻辑问题

worker进程会在**ngx_worker_process_cycle**中死循环执行**ngx_process_events_and_timers**()函数，而并没有检查程序退出标记g_stopEvent，因此永远不会跳出for循环，也不会执行后续的线程池处理函数**StopAll**和进程关闭函数**Shutdown_subproc**。

是否相应的信号处理可以实现跳出for循环？

## 信号处理模块的实现？

自定义了一个信号结构体**ngx_signal_t**，包括信号的数字编号，信号的名字以及处理函数

用一个**signals数组**，里面记录了很多自定义的**信号结构体**，每一个结构体对应一个我们**关注的信号**。

程序初始化阶段调用了**ngx_init_signals**函数，进行了：

- 根据signals数组设置每个信号的处理函数
- 清空信号掩码（**sigemptyset**(&sa.sa_mask);表示在处理当前信号时不阻塞任何其他信号）
- **sigaction**(sig->signo, &sa, NULL。**sigaction函数**（代替了老的signal函数）是一个系统调用，用来设置一个信号的信号处理函数，这里的sa是一个**sigaction结构体**

```C++
struct sigaction {
    void     (*sa_handler)(int);                    // 旧式信号处理函数
    void     (*sa_sigaction)(int, siginfo_t *, void *); // 新式信号处理函数
    sigset_t sa_mask;       // 信号掩码
    int      sa_flags;      // 信号处理的标志位
    void     (*sa_restorer)(void);    // 已废弃
};
```

目前的信号处理函数功能有限，只对SIGCHLD有最基本的处理（仅设置标志），应有的逻辑如下：

```C++
switch (signo) {
    case SIGTERM:
    case SIGINT:
    case SIGQUIT:
        g_stopEvent = true;  // 设置退出标志
        break;
    case SIGHUP:
        reload_flag = true;  // 设置重载标志
        break;
    case SIGCHLD:
        ngx_reap = 1;       // 子进程处理
        break;
}
```

## 心跳线程的逻辑

采用**std**::**multimap**<**time_t**, **LPSTRUC_MSG_HEADER**>作为超时连接队列。

> [!NOTE]
>
> ###### 为什么用multimap？
>
> 相比map：可自动按时间升序排列
>
> 相比升序链表：需要额外排序
>
> 相比优先队列：优先队列不支持删除中间元素
>
> **改进**：用一个unordered_map存储连接和定时器指针键值对

一个新连接何时被加入超时队列？

accept一个新连接时，在最后会调用**AddToTimerQueue**函数，给每个连接设定**超时时间**（**当前时间+m_iWaitTime**）。

心跳线程：检查时间队列，如果有超时（超时判定：**超时队列的第一个连接的超时时间小于当前时间**），就把超时节点都拿出来，调用**procPingTimeOutChecking**进行处理。

### 时间模块的功能函数：

1.添加到事件队列**AddToTimerQueue**

2.获取第一个超时项**GetOverTimeTimer**，两种处理模式

- **严格模式**：发现连接超时，直接**将连接从超时列表中删除**，断开连接的工作由procPingTimeOutChecking来做
- **宽松模式**：发现超时不会立即断开，而是更新超时时间（原有超时时间加了一个m_iWaitTime），宽松模式下将连接从超时列表中删除的工作由DeleteFromTimerQueue来做

3.处理一个超时项**procPingTimeOutChecking**

根据配置选择**直接踢出**或**根据超时时间判断是否踢出**，如果是已经断开的连接，则只释放内存。如此设计实现了两级超时保护，可分别适用于**严格模式**和**宽松模式**

4.更新超时时间**UpdateTimer**

5.从超时队列删除一个指定的超时项**DeleteFromTimerQueue**

6.获取超时队列的第一个元素的超时时间**GetEarliestTime**

7.移除超时队列的第一个元素**RemoveFirstTimer**

### 时间模块的配置变量：

1.资源延迟回收时间Sock_RecyConnectionWaitTime = 150

2.是否开启踢人Sock_WaitTimeEnable = 1

3.多少秒检测一次是否心跳超时Sock_MaxWaitTime = 20

4.是否开启立即踢出模式Sock_TimeOutKick = 0，默认不开启。开启（Sock_TimeOutKick = 1）则为严格模式：20秒不响应就踢出

## 内存分配模块的问题

- 当前实现不够优雅，用了另一个类来负责在其析构函数中释放CMemory单例
- 直接把CMemory创建为局部静态变量即可

## 读取配置模块

数据结构：

```C++
// 配置项结构
typedef struct _CConfItem
{
    char ItemName[50];      // 配置项名称
    char ItemContent[500];  // 配置项内容
}CConfItem,*LPCConfItem;

// 配置列表
std::vector<LPCConfItem> m_ConfigItemList;
```

三个函数：

- 获取配置文件Load
- 获取字符串配置GetString
- 获取整数配置GetIntDEfault

## 套接字的初始化问题

读取配置文件，绑定指定端口和**INADDR_ANY**

使用非阻塞socket，并启用**SO_REUSEADDR**和**SO_REUSEPORT**

- SO_REUSEADDR解决**time_wait**问题，并允许多个套接字绑定到**不同IP+相同端口**
- SO_REUSEPORT可实现多个套接字绑定**同一个ip地址+端口号**，实现多进程**负载均衡**，**避免惊群**，并可以**无缝重启**（新旧进程共存）

\- 使用m_ListenSocketList维护所有监听socket

\- 每个监听socket都有独立的ngx_listening_t结构

> [!NOTE]
>
> ###### 在没有SO_RUSEPORT的时候，惊群问题怎么解决？
>
> 1.让多进程竞争锁，拿到锁的进程accept（Nginx方案）
>
> 2.增加代理进行转发，采用轮询或哈希等策略分发（Proxy方案）

## 新连接到来时哪个子进程接收的问题

1.传统惊群问题

- 如果不使用SO_REUSEPORT
- 多个worker进程同时监听同一个端口
- 新连接到来时所有worker都会被唤醒
- 但只有一个worker能accept成功
- 其他worker accept失败，造成资源浪费

2.使用SO_REUSEPORT后

- 内核会实现负载均衡
- 当新连接到来时，内核会选择一个worker进程
- 只有被选中的worker进程会被唤醒
- 避免了惊群问题
- 实现了连接的均匀分配

3.SO_REUSEPORT的工作原理

- 允许多个socket绑定到同一个端口
- 内核维护这些socket的负载均衡表
- 使用socket的哈希算法决定将连接分配给哪个worker
- 哈希因子包括：源IP、源端口、目的IP、目的端口等

4.相比accept互斥锁

- 无需在用户态实现加锁逻辑
- 由内核直接进行负载均衡
- 性能更好，无锁开销

5.相比SO_REUSEADDR

- SO_REUSEADDR只解决端口复用问题
- SO_REUSEPORT还实现了负载均衡
- 更均匀地分配连接

### 新连接建立的总流程

1. master进程创建监听socket并设置SO_REUSEPORT
2. fork出worker进程，继承监听socket
3. 每个worker进程独立监听这些socket
4. 新连接到来时，内核选择一个worker
5. 被选中的worker通过epoll获得通知
6. worker调用accept接受连接

## flood攻击检测

在CSocket中实现了一个TestFlood函数：

1.如果两次收包的时间间隔小于阈值，则判定其可能为flood攻击，并将攻击次数加一，如果两次收包时间大于阈值，则将攻击次数归零。

2.若攻击次数超过某一阈值，则判定为flood攻击，标记要踢出该连接。

3.在读回调函数中检测是否为flood攻击，如果是，就调用**zdClosesocketProc**(pConn)将该连接干掉

## 日志模块

采用全局变量（一个文件描述符）来记录日志，通过调用全局函数来写日志。

**ngx_log_stderr**:用于需要同时在屏幕和日志文件显示的错误(因为没有将标准错误重定向到/dev/null，所以可以输出到屏幕，可用于开发环境，在**生产环境中一般要关闭**)

**ngx_log_error_core**: 用于只需要写入日志文件的普通日志

设置了八个级别的日志

**缺陷**：仅有一个日志文件，以追加的方式写入，只要磁盘有空间就会一直写。

**改进**：大小限制，日志轮转，定期清理

## 自定义输出函数（仿nginx）

- ngx_printf实现了一套完整的格式化字符串功能

  主要用于日志、错误处理等需要字符串格式化的场景

- 提供了安全的边界检查机制

- 支持常用的格式化类型

- 在项目中被广泛使用，特别是日志模块

**各函数特点和使用建议**：

a) **ngx_slprintf**:

- 带边界检查的格式化

- 适用于已知缓冲区起止位置的场景

- 返回写入位置的指针，方便连续写入

b) **ngx_snprintf**:

- 指定最大长度的格式化

- 更安全，防止缓冲区溢出

- 适用于简单的字符串格式化

c) **ngx_vslprintf**:

- 核心实现，支持va_list

- 不建议直接使用

- 其他格式化函数的基础

d) **ngx_sprintf_num**:

- 内部函数，用于数字转字符串

- 支持十进制和十六进制

- 支持固定宽度和补零

> [!NOTE]
>
> ###### va_list是一个类型，用于存储可变参数的信息，是C语言的一部分，定义在<stdarg.h>(C)或<cstdarg>(C++)中
>
> - va_list是C/C++中处理可变参数的传统方式（可以处理任意数量参数，但必须知道参数类型）
> - 现代C++提供了更安全的替代方案（可变参数模板）
> - 选择哪种方案取决于具体需求和环境限制
> - 在需要格式化字符串的场景，va_list仍然很常用
>
> ```C++
> //更现代的C++方案
> template<typename... Args>
> void modern_printf(const char* fmt, Args... args)
> {
>     printf(fmt, args...);
> }
> 
> //可变参数模板
> template<typename... Args>
> void log(const char* fmt, Args... args)
> {
>     size_t size = snprintf(nullptr, 0, fmt, args...) + 1;
>     std::vector<char> buf(size);
>     snprintf(buf.data(), size, fmt, args...);
>     //处理buf中的内容...
> }
> ```

## 修改进程标题功能

**工作原理**：

- Linux进程标题修改的本质是修改argv[0]的内容

- 由于argv和environ在内存中是连续的，需要先保存环境变量

- 将环境变量复制到新内存后，原来的空间可以用来存储新标题

**实现要点**：

- 需要先调用ngx_init_setproctitle()初始化

- 环境变量必须先保存，因为会被覆盖

- 标题长度不能超过原始命令行+环境变量的总长度

- 使用memset清零未使用的空间，避免残留

**注意事项**：

- 修改进程标题后，原始的命令行参数将不可用（解决方案是在修改标题前保存参数）

- 必须在fork()子进程前初始化

- 标题长度有限制，不能太长

- 需要足够的内存来保存环境变量副本

ngx_init_setproctitle()负责保护环境变量，即找一块新内存保存

> [!NOTE]
>
> ###### 环境变量的作用
>
> 环境变量用于在进程运行时提供配置和系统信息
>
> 常用于：
>
> - 查找路径（可执行文件、库、配置等）
>
> - 获取系统信息（语言、用户目录等）
>
> - 进程间传递信息
>
> - 控制程序行为（调试、日志等）
>
> 读取时机：
>
> - 程序初始化时
>
> - 加载动态库时
>
> - 处理特定请求时
>
> - 需要系统信息时
>
> 保护环境变量很重要，因为程序运行过程中可能随时需要访问

ngx_setproctitle()负责实际修改进程标题

环境变量被挪到了别处，进程如何知道去哪里访问？

environ是全局变量

- 通过更新environ全局变量中的指针，实现环境变量位置的转移
- 所有标准库函数（如getenv）都通过environ访问环境变量
- 不需要修改任何调用代码，对使用者透明
- 子进程和exec调用都能正确继承新的环境变量位置
- 这种方式简单有效，不影响程序的正常运行
